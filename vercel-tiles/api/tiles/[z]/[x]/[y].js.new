import { Pool } from 'pg';
import h3 from 'h3-js';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
});

const ZOOM_TO_H3 = {
  0: 2, 1: 2, 2: 3, 3: 4, 4: 4, 5: 5,
  6: 6, 7: 7, 8: 7, 9: 8, 10: 8, 11: 9,
  12: 9, 13: 10, 14: 10, 15: 10, 16: 11,
  17: 11, 18: 11, 19: 12, 20: 12
};

function tileToBBox(z, x, y) {
  const n = Math.PI - (2 * Math.PI * y) / Math.pow(2, z);
  const lat1 = (Math.atan(Math.sinh(n)) * 180) / Math.PI;
  const lng1 = (x / Math.pow(2, z)) * 360 - 180;

  const n2 = Math.PI - (2 * Math.PI * (y + 1)) / Math.pow(2, z);
  const lat2 = (Math.atan(Math.sinh(n2)) * 180) / Math.PI;
  const lng2 = ((x + 1) / Math.pow(2, z)) * 360 - 180;

  return [lng1, lat2, lng2, lat1];
}

function getH3CellsForBBox(west, south, east, north, resolution) {
  try {
    const polygon = [[
      [north, west],
      [north, east],
      [south, east],
      [south, west],
      [north, west]
    ]];

    return h3.polygonToCells(polygon, resolution);
  } catch (error) {
    console.warn('H3 polyfill failed:', error.message);
    const centerLat = (south + north) / 2;
    const centerLng = (west + east) / 2;
    return [h3.latLngToCell(centerLat, centerLng, resolution)];
  }
}

export default async function handler(req, res) {
  const { z, x, y } = req.query;

  // Set CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  const zoom = parseInt(z);
  const tileX = parseInt(x);
  const tileY = parseInt(y);

  if (isNaN(zoom) || isNaN(tileX) || isNaN(tileY)) {
    return res.status(400).json({ error: 'Invalid tile coordinates' });
  }

  const h3Level = ZOOM_TO_H3[zoom] || 8;
  const [west, south, east, north] = tileToBBox(zoom, tileX, tileY);

  try {
    const h3Cells = getH3CellsForBBox(west, south, east, north, h3Level);

    if (!h3Cells.length) {
      return res.status(200).json({
        type: 'FeatureCollection',
        features: []
      });
    }

    let features = [];
    let useDbData = false;

    // Try to get data from database first
    try {
      const client = await pool.connect();

      try {
        // Query database for property data within these H3 cells
        const query = `
          SELECT 
            h3_index,
            AVG(price) as price,
            COUNT(*) as count,
            AVG(confidence) as confidence,
            AVG(value) as value
          FROM property_data
          WHERE h3_index = ANY($1)
          GROUP BY h3_index
        `;

        const result = await client.query(query, [h3Cells]);

        if (result.rows.length > 0) {
          useDbData = true;

          // Create a map of h3_index to data for quick lookup
          const dataMap = {};
          result.rows.forEach(row => {
            dataMap[row.h3_index] = {
              price: parseFloat(row.price),
              count: parseInt(row.count),
              confidence: parseFloat(row.confidence),
              value: parseFloat(row.value)
            };
          });

          // Build features from database data
          features = h3Cells.map(cell => {
            try {
              const boundary = h3.cellToBoundary(cell, true);
              const coordinates = boundary.map(([lat, lng]) => [lng, lat]);
              coordinates.push(coordinates[0]);

              // Use real data if available, otherwise skip
              if (dataMap[cell]) {
                return {
                  type: 'Feature',
                  properties: {
                    price: dataMap[cell].price,
                    count: dataMap[cell].count,
                    confidence: dataMap[cell].confidence,
                    value: dataMap[cell].value,
                    h3_index: cell,
                  },
                  geometry: {
                    type: 'Polygon',
                    coordinates: [coordinates]
                  }
                };
              }
              return null;
            } catch (error) {
              console.error(`Error processing cell ${cell}:`, error);
              return null;
            }
          }).filter(Boolean);
        }
      } finally {
        client.release();
      }
    } catch (dbError) {
      console.warn('Database connection failed, using mock data:', dbError.message);
    }

    // If no database data was retrieved, use mock data
    if (!useDbData) {
      features = h3Cells.map((cell, index) => {
        try {
          const boundary = h3.cellToBoundary(cell, true);
          const coordinates = boundary.map(([lat, lng]) => [lng, lat]);
          coordinates.push(coordinates[0]);

          const mockPrice = 200000 + (Math.random() * 800000);
          const mockCount = Math.floor(Math.random() * 50) + 1;
          const mockConfidence = 0.3 + (Math.random() * 0.7);
          const mockValue = Math.random();

          return {
            type: 'Feature',
            properties: {
              price: mockPrice,
              count: mockCount,
              confidence: mockConfidence,
              value: mockValue,
              h3_index: cell,
            },
            geometry: {
              type: 'Polygon',
              coordinates: [coordinates]
            }
          };
        } catch (error) {
          return null;
        }
      }).filter(Boolean);
    }

    const geojson = {
      type: 'FeatureCollection',
      features: features
    };

    res.setHeader('Content-Type', 'application/geo+json');
    res.setHeader('Cache-Control', 'public, max-age=3600');

    return res.status(200).json(geojson);

  } catch (error) {
    console.error('Tile error:', error);
    return res.status(200).json({
      type: 'FeatureCollection',
      features: []
    });
  }
}
